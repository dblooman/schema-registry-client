// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new operations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for operations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	DeleteSchemaVersion(params *DeleteSchemaVersionParams) (*DeleteSchemaVersionOK, error)

	DeleteSubject(params *DeleteSubjectParams) (*DeleteSubjectOK, error)

	Get(params *GetParams) (*GetOK, error)

	GetClusterID(params *GetClusterIDParams) (*GetClusterIDOK, error)

	GetMode(params *GetModeParams) (*GetModeOK, error)

	GetReferencedBy(params *GetReferencedByParams) (*GetReferencedByOK, error)

	GetSchema(params *GetSchemaParams) (*GetSchemaOK, error)

	GetSchemaByVersion(params *GetSchemaByVersionParams) (*GetSchemaByVersionOK, error)

	GetSchemaOnly(params *GetSchemaOnlyParams) (*GetSchemaOnlyOK, error)

	GetSchemaTypes(params *GetSchemaTypesParams) (*GetSchemaTypesOK, error)

	GetSchemas(params *GetSchemasParams) (*GetSchemasOK, error)

	GetSubjectLevelConfig(params *GetSubjectLevelConfigParams) (*GetSubjectLevelConfigOK, error)

	GetSubjects(params *GetSubjectsParams) (*GetSubjectsOK, error)

	GetTopLevelConfig(params *GetTopLevelConfigParams) (*GetTopLevelConfigOK, error)

	GetTopLevelMode(params *GetTopLevelModeParams) (*GetTopLevelModeOK, error)

	GetVersions(params *GetVersionsParams) (*GetVersionsOK, error)

	List(params *ListParams) (*ListOK, error)

	ListVersions(params *ListVersionsParams) (*ListVersionsOK, error)

	LookUpSchemaUnderSubject(params *LookUpSchemaUnderSubjectParams) error

	Post(params *PostParams) (*PostOK, error)

	Register(params *RegisterParams) (*RegisterOK, error)

	TestCompatibilityBySubjectName(params *TestCompatibilityBySubjectNameParams) (*TestCompatibilityBySubjectNameOK, error)

	UpdateMode(params *UpdateModeParams) (*UpdateModeOK, error)

	UpdateSubjectLevelConfig(params *UpdateSubjectLevelConfigParams) (*UpdateSubjectLevelConfigOK, error)

	UpdateTopLevelConfig(params *UpdateTopLevelConfigParams) (*UpdateTopLevelConfigOK, error)

	UpdateTopLevelMode(params *UpdateTopLevelModeParams) (*UpdateTopLevelModeOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  DeleteSchemaVersion deletes a specific version of the schema registered under this subject this only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID this API is recommended to be used only in development environments or under extreme circumstances where in its required to delete a previously registered schema for compatibility purposes or re register previously registered schema
*/
func (a *Client) DeleteSchemaVersion(params *DeleteSchemaVersionParams) (*DeleteSchemaVersionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSchemaVersionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteSchemaVersion",
		Method:             "DELETE",
		PathPattern:        "/subjects/{subject}/versions/{version}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteSchemaVersionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteSchemaVersionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteSchemaVersion: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteSubject deletes the specified subject and its associated compatibility level if registered it is recommended to use this API only when a topic needs to be recycled or in development environment
*/
func (a *Client) DeleteSubject(params *DeleteSubjectParams) (*DeleteSubjectOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSubjectParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteSubject",
		Method:             "DELETE",
		PathPattern:        "/subjects/{subject}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteSubjectReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteSubjectOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteSubject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Get schemas registry root resource

  The Root resource is a no-op.
*/
func (a *Client) Get(params *GetParams) (*GetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get",
		Method:             "GET",
		PathPattern:        "/",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for get: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetClusterID gets the server metadata
*/
func (a *Client) GetClusterID(params *GetClusterIDParams) (*GetClusterIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getClusterId",
		Method:             "GET",
		PathPattern:        "/v1/metadata/id",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetClusterIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getClusterId: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetMode get mode API
*/
func (a *Client) GetMode(params *GetModeParams) (*GetModeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetModeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getMode",
		Method:             "GET",
		PathPattern:        "/mode/{subject}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetModeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetReferencedBy gets the schemas that reference the specified schema
*/
func (a *Client) GetReferencedBy(params *GetReferencedByParams) (*GetReferencedByOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetReferencedByParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getReferencedBy",
		Method:             "GET",
		PathPattern:        "/subjects/{subject}/versions/{version}/referencedby",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReferencedByReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetReferencedByOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getReferencedBy: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetSchema gets the schema string identified by the input ID
*/
func (a *Client) GetSchema(params *GetSchemaParams) (*GetSchemaOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSchemaParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSchema",
		Method:             "GET",
		PathPattern:        "/schemas/ids/{id}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSchemaReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSchemaOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSchema: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetSchemaByVersion gets a specific version of the schema registered under this subject
*/
func (a *Client) GetSchemaByVersion(params *GetSchemaByVersionParams) (*GetSchemaByVersionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSchemaByVersionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSchemaByVersion",
		Method:             "GET",
		PathPattern:        "/subjects/{subject}/versions/{version}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSchemaByVersionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSchemaByVersionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSchemaByVersion: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetSchemaOnly gets the schema for the specified version of this subject the unescaped schema only is returned
*/
func (a *Client) GetSchemaOnly(params *GetSchemaOnlyParams) (*GetSchemaOnlyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSchemaOnlyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSchemaOnly",
		Method:             "GET",
		PathPattern:        "/subjects/{subject}/versions/{version}/schema",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSchemaOnlyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSchemaOnlyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSchemaOnly: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetSchemaTypes gets the schema types supported by this registry
*/
func (a *Client) GetSchemaTypes(params *GetSchemaTypesParams) (*GetSchemaTypesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSchemaTypesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSchemaTypes",
		Method:             "GET",
		PathPattern:        "/schemas/types",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSchemaTypesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSchemaTypesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSchemaTypes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetSchemas gets the schemas
*/
func (a *Client) GetSchemas(params *GetSchemasParams) (*GetSchemasOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSchemasParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSchemas",
		Method:             "GET",
		PathPattern:        "/schemas",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSchemasReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSchemasOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSchemas: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetSubjectLevelConfig gets compatibility level for a subject
*/
func (a *Client) GetSubjectLevelConfig(params *GetSubjectLevelConfigParams) (*GetSubjectLevelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSubjectLevelConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSubjectLevelConfig",
		Method:             "GET",
		PathPattern:        "/config/{subject}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSubjectLevelConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSubjectLevelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSubjectLevelConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetSubjects gets all the subjects associated with the input ID
*/
func (a *Client) GetSubjects(params *GetSubjectsParams) (*GetSubjectsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSubjectsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSubjects",
		Method:             "GET",
		PathPattern:        "/schemas/ids/{id}/subjects",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSubjectsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSubjectsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSubjects: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetTopLevelConfig gets global compatibility level
*/
func (a *Client) GetTopLevelConfig(params *GetTopLevelConfigParams) (*GetTopLevelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTopLevelConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTopLevelConfig",
		Method:             "GET",
		PathPattern:        "/config",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetTopLevelConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetTopLevelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getTopLevelConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetTopLevelMode get top level mode API
*/
func (a *Client) GetTopLevelMode(params *GetTopLevelModeParams) (*GetTopLevelModeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTopLevelModeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTopLevelMode",
		Method:             "GET",
		PathPattern:        "/mode",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetTopLevelModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetTopLevelModeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getTopLevelMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetVersions gets all the subject version pairs associated with the input ID
*/
func (a *Client) GetVersions(params *GetVersionsParams) (*GetVersionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetVersionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getVersions",
		Method:             "GET",
		PathPattern:        "/schemas/ids/{id}/versions",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetVersionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetVersionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getVersions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  List gets a list of registered subjects
*/
func (a *Client) List(params *ListParams) (*ListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "list",
		Method:             "GET",
		PathPattern:        "/subjects",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for list: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ListVersions gets a list of versions registered under the specified subject
*/
func (a *Client) ListVersions(params *ListVersionsParams) (*ListVersionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVersionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listVersions",
		Method:             "GET",
		PathPattern:        "/subjects/{subject}/versions",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVersionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListVersionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listVersions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  LookUpSchemaUnderSubject checks if a schema has already been registered under the specified subject if so this returns the schema string along with its globally unique identifier its version under this subject and the subject name
*/
func (a *Client) LookUpSchemaUnderSubject(params *LookUpSchemaUnderSubjectParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLookUpSchemaUnderSubjectParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "lookUpSchemaUnderSubject",
		Method:             "POST",
		PathPattern:        "/subjects/{subject}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &LookUpSchemaUnderSubjectReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil
}

/*
  Post post API
*/
func (a *Client) Post(params *PostParams) (*PostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post",
		Method:             "POST",
		PathPattern:        "/",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PostOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for post: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Register registers a new schema under the specified subject if successfully registered this returns the unique identifier of this schema in the registry the returned identifier should be used to retrieve this schema from the schemas resource and is different from the schema s version which is associated with the subject if the same schema is registered under a different subject the same identifier will be returned however the version of the schema may be different under different subjects a schema should be compatible with the previously registered schema or schemas if there are any as per the configured compatibility level the configured compatibility level can be obtained by issuing a g e t http get config string subject if that returns null then g e t http get config when there are multiple instances of schema registry running in the same cluster the schema registration request will be forwarded to one of the instances designated as the primary if the primary is not available the client will get an error code indicating that the forwarding has failed
*/
func (a *Client) Register(params *RegisterParams) (*RegisterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRegisterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "register",
		Method:             "POST",
		PathPattern:        "/subjects/{subject}/versions",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RegisterReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RegisterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for register: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  TestCompatibilityBySubjectName tests input schema against a particular version of a subject s schema for compatibility

  the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).
*/
func (a *Client) TestCompatibilityBySubjectName(params *TestCompatibilityBySubjectNameParams) (*TestCompatibilityBySubjectNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestCompatibilityBySubjectNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testCompatibilityBySubjectName",
		Method:             "POST",
		PathPattern:        "/compatibility/subjects/{subject}/versions/{version}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TestCompatibilityBySubjectNameReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*TestCompatibilityBySubjectNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for testCompatibilityBySubjectName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateMode update mode API
*/
func (a *Client) UpdateMode(params *UpdateModeParams) (*UpdateModeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateModeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateMode",
		Method:             "PUT",
		PathPattern:        "/mode/{subject}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateModeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateSubjectLevelConfig updates compatibility level for the specified subject
*/
func (a *Client) UpdateSubjectLevelConfig(params *UpdateSubjectLevelConfigParams) (*UpdateSubjectLevelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSubjectLevelConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateSubjectLevelConfig",
		Method:             "PUT",
		PathPattern:        "/config/{subject}",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateSubjectLevelConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateSubjectLevelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateSubjectLevelConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateTopLevelConfig updates global compatibility level
*/
func (a *Client) UpdateTopLevelConfig(params *UpdateTopLevelConfigParams) (*UpdateTopLevelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateTopLevelConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateTopLevelConfig",
		Method:             "PUT",
		PathPattern:        "/config",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateTopLevelConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateTopLevelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateTopLevelConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateTopLevelMode update top level mode API
*/
func (a *Client) UpdateTopLevelMode(params *UpdateTopLevelModeParams) (*UpdateTopLevelModeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateTopLevelModeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateTopLevelMode",
		Method:             "PUT",
		PathPattern:        "/mode",
		ProducesMediaTypes: []string{"application/json; qs=0.5", "application/vnd.schemaregistry+json; qs=0.9", "application/vnd.schemaregistry.v1+json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream", "application/vnd.schemaregistry+json", "application/vnd.schemaregistry.v1+json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateTopLevelModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateTopLevelModeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateTopLevelMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
